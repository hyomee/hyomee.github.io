# 메시징 시스템

메시징 시스템은 서로 다른 시스템끼리 정보를 교환하기 위한 통합 채널로 다음과 같은 원칙이 있습니다,

* **느슨한 연계(Loose Coupling)**: 시스템(or 어플리케이션) 상호 간에 의존성을 최소화 하는 것으로 한쪽에서 발생한 변경이 다른 시스템(or 어플리케이션)에 영향을 주지 않아야 합니다.
* **공통 인퍼페이스(Common Interface)**:  시스템(or 어플리케이션) 간에 데이터 교환을 위해 공통으로 지정된 데이터 형식을 보장해야 합니다. 즉 메세지 교환을 위한 표준 수립을 하여야 합니다. (예: 아피치 에이브로(Avro)데이터 형식 도입 )
* **응답 속도(Lantency)**: 메세지 전송부터 수신까지 소요되는 시간으로 빠른 응답 속도를 요구합니다.
* **신뢰성(Reliability)**: 일시적인 가용성 문제가 발생해도 메세지 교환은 영향을 받지 말아야 합니다.

<details>

<summary>아파치 에이브로(Avro)</summary>

아파치 하둡 프로젝트에서 개발된 **원격 프로시저 호출(RPC)** 및 **데이터 직렬화 프레임워크**입니다. 이 프레임워크는 다음과 같은 특징을 가지고 있습니다:

1. **스키마 기반 직렬화**:
   * 에이브로는 **JSON 스키마**를 사용하여 데이터를 정의하고 직렬화합니다. 이를 통해 데이터를 구조화하고 유연하게 처리할 수 있습니다.
   * 스키마를 함께 저장하여 데이터를 읽을 때 미리 스키마를 알지 않아도 됩니다.
2. **컴팩트 바이너리 형식**:
   * 에이브로는 데이터를 **콤팩트한 바이너리 형식**으로 직렬화합니다. 이는 크기가 작고 빠르게 전송할 수 있도록 합니다.
   * JSON 인코딩도 지원하며, 디버깅이나 웹 기반 애플리케이션에서 유용합니다.
3. **하둡 데이터 직렬화 구성 요소**:
   * 아파치 하둡에서 클라이언트와 하둡 서비스 간의 통신에 사용되는 **와이어 포맷**과 영구 데이터를 위한 **직렬화 포맷**을 모두 제공합니다.
4. **스키마 변경에 유연**:
   * 스리프트나 프로토콜 버퍼와 유사하지만, 스키마 변경이 발생할 때 코드 생성 프로그램의 실행을 요구하지 않습니다.

</details>

<details>

<summary><strong>가용성</strong></summary>

서버와 네트워크, 프로그램 등의 정보 시스템이 정상적으로 사용 가능한 정도를 의미합니다. 이는 시스템이 정해진 시간 동안 장애 없이 기능을 수행할 수 있는 확률을 나타냅니다

</details>

<details>

<summary>메시지 지향 미들웨어(MOM: Message Oriented Middleware)</summary>

분산 시스템에서 메세지를 보내고 받을 수 있는 소프트웨어 또는 하드웨어 인프라

</details>

## 1. 왜  메시징 시스템

전통적인 시스템은 업무를 순차적으로 처리합니다. 예를 들어, 쇼핑몰 웹사이트에서 회원가입을 하고, 물품을 구매하고, 배송을 처리할 때, 모놀리식 시스템은 모든 애플리케이션을 하나의 서버와 DB에서 처리합니다. 사용자가 많아질수록 시스템을 확장(Scale out/up)해야 하지만, 이는 성능 유지에 한계가 있습니다. 회원가입, 물품 구매, 배송이 각각 분리되어 있으면, 시스템 간 메시지 전달을 통해 성능을 유지할 수 있습니다. 물론, 한 시스템에 있을 때와는 다른 여러 고려 사항이 있지만, 메시지를 비동기적으로 전달하고 각 시스템이 물리적으로 분리되며 DB도 분리된다면, 각 시스템은 사용자 증가에도 성능을 보장할 수 있습니다. 자세한 내용은 분산 시스템과 MSA에 대해 알아보시기 바랍니다.

## 2. 메시징 기본 용어

* **메세지 큐(Message Queue)**: 메시지 큐는 시스템(또는 어플리케이션) 간 메시지 교환을 위한 통신 방법 중 하나로, 메시지를 일시적으로 저장하는 간단한 버퍼로 볼 수 있습니다. 메시지 전송과 수신을 위해 중간 단계로 메시지 큐를 사용합니다.
*   **메세지(Data P**acket**)**: 네트워크 통신에서 데이터 전송의 기본 단위는 패킷이며, 이는 데이터를 작은 조각으로 나누어 이동시킵니다. 패킷은 제어 정보와 사용자 데이터, 즉 페이로드로 구성됩니다. 보통 패킷은 헤더, 데이터, 트레일러로 구성되어 있습니다.\


    <figure><img src="../../.gitbook/assets/image (464).png" alt=""><figcaption></figcaption></figure>

<details>

<summary>패킷(<strong>P</strong>acket)</summary>

네트워크 통신에서 데이터를 전송하는 단위를 의미합니다. 네트워크에서 데이터는 작은 조각으로 나누어져 전송되며, 이러한 작은 조각을 패킷이라고 합니다. 패킷은 송신자에서 수신자로 전달되는 동안 여러 노드를 거쳐 전송되며, 각 노드에서는 패킷을 검사하고 라우팅하여 최종 목적지까지 전달됩니다. 패킷은 헤더와 데이터로 구성되며, 헤더에는 출발지, 목적지, 길이, 제어 정보 등이 포함됩니다. 이렇게 작은 단위로 데이터를 나누어 전송함으로써 효율적이고 신속한 통신이 가능해집니다. 패킷은 인터넷과 같은 네트워크에서 중요한 역할을 하며, 데이터를 안정적으로 전달하는 데 필수적입니다

</details>

* **Sender(Producer)**: 메시지 큐와 메시지 브로커는 컴퓨터 시스템에서 메시지를 안전하고 효율적으로 전달하기 위한 소프트웨어나 서비스로메세지를 생성하고 메세지 규나 메세지 브로커에 전달하는 데이터 소스로 메시징 시스템의 유형에 따라 하나씩 보내는 방식과 일괄적인 배치로 보내는 방식이 있습니다.
* **Receiver(Consumer**): 메시지 큐와 메시지 브로커에서는 메시지를 소비하는 역할을 하는 컴포넌트로 메시지 큐에서 메시지를 가져와 처리하거나, 메시지 브로커에서 메시지를 수신하여 해당 메시지를 소비하는 역할을 합니다

<details>

<summary>메세지 큐와 메세지 브로커의 차이점 </summary>

메시지 큐는 개별 메시지를 전달하는 P2P 방식의 1:1 메시지 중계를 제공하고, 메시지 브로커는 중앙 집중식 아키텍처를 통해 1:N, N:1의 브로드 캐스트 스타일의 메시지 중계를 지원합니다

1. **메시지 큐 (Message Queue)**:
   * **메시지 큐**는 컴퓨터 시스템에서 다른 프로세스나 컴포넌트 간의 메시지를 안전하고 효율적으로 전달하기 위한 소프트웨어나 서비스입니다.
   * 큐 자체는 선입 선출의 구조를 가진 자료구조로, 메시지를 전달하는 Producer(송신자) 부분(입구)과 메시지를 받아 이를 소비하는 Consumer(수신자) 부분(출구) 사이에서 메시지를 전달하는 매개체입니다.
   * 메시지 큐는 비동기 프로세스 제어, 낮은 결합도 유지, 시스템 신뢰성 및 안정성 보장, 확장성 등의 장점을 활용하여 현대적인 소프트웨어 아키텍처에서 필수적인 요소로 활용됩니다[1](https://velog.io/@beberiche/Architecture-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EC%99%80-%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4-MSA%EC%9D%98-%ED%95%B5%EC%8B%AC%EC%9A%94%EC%86%8C).
2. **메시지 브로커 (Message Broker)**:
   * 메시지 브로커는 메시지 큐를 대규모 트래픽을 감당해야하는 어플리케이션의 장점에 맞게 확장한 기술입니다.
   * 기존 메시지 큐는 전달하는 쪽에서 전달 받는 쪽으로 메시지를 전달하는 매개체로서의 의미를 가지고 있습니다. 반면, 메시지 브로커는 더 광범위한 전송과 라우팅을 허용하며, 중앙 집중식 아키텍처를 채택하여 1:N, N:1의 브로드 캐스트 스타일의 메시지 중계를 제공합니다[2](https://bing.com/search?q=%EB%A9%94%EC%8B%9C%EC%A7%80+%ED%81%90%EC%99%80+%EB%A9%94%EC%8B%9C%EC%A7%80+%EB%B8%8C%EB%A1%9C%EC%BB%A4%EC%9D%98+%EC%B0%A8%EC%9D%B4).

</details>

* **Protocol:** 시스템(또는 어플리케이션) 간에 메세지 교환에 대한 규칙으로 데이터 전송 프로토콜에는 다음과 같은 것들이 있습니다.
  * **AMQP(Advanced Messing Queueing Protocol)**:  메시지 지향 미들웨어(MOM) 시스템 간에 통신하기 위한 개방형 네트워크 프로토콜입니다[1](https://velog.io/@black\_han26/AMQPAdvanced-Message-Queuing-Protocol). 간단히 말해서,   송신자(Producer)와 **수신자(Consumer)** 사이에서 메시지를 안전하게 교환하는 표준 프로토콜입니다
  * **STOMP(Streaming Text Oriented Message Protocol):** 웹소켓 위에서 동작하는 문자 기반 메시징 프로토콜입니다.(Pub/Sub 구조)
  * **MQTT(Message Queue Telemetry Transport):** 경량 및 효율적인 대역폭을 사용하여 멀티 레벨의 QoS(Quality of Service)를 지원하며, 현재는 IoT 또는 M2M (machine to machine communications) 통신에 많이 사용됩니다(Broker/Publisher/Subscriber 구조)
  * **HTTP(Hypertext Transfer Protocol)/HTTPS (Hypertext Transfer Protocol Secure**):  클라이언트와 서버 사이에 이루어지는 요청/응답 (request/response) 프로토콜로 HTTPS  보안이 강화된 것 입니다,
  * **FTP(File Transfer Protocol)**: TCP/IP 프로토콜을 사용하여 서버와 클라이언트 사이의 파일 전송을 위한 프로토콜입니다
  * SMTP (Simple Mail Transfer Protocol), POP3 (Post Office Protocol version 3), IMAP (Internet Message Access Protocol), TCP (Transmission Control Protocol), UDP (User Datagram Protocol), DNS (Domain Name System) 등이 있습니다.

## 3. 메시징 시스템 모델

### **3-1. Point-to-Point (P2P) 모델**:

* &#x20;메시지를 발신하는 Producer와 메시지를 수신하는 Consumer가 직접적으로 연결됩니다.
* 메시지는 큐를 통해 전달되며, Consumer는 큐에서 메시지를 하나씩 꺼내 읽습니다.
*   P2P 모델은 1:1 통신을 지원하며, 메시지의 안정성과 순서를 보장합니다.\


    <figure><img src="../../.gitbook/assets/image (474).png" alt=""><figcaption></figcaption></figure>

#### 3-1-1. PTP 메시징 모델은 다음의 두가지 유형

1. **Fire-and-forget Model:**&#x20;
   * 메시지를 발신하는 측은 메시지를 보낸 후 응답을 기다리지 않고 다른 작업을 수행할 수 있습니다.&#x20;
   * 메시지는 수신자에게 전달되며, 수신자는 메시지를 처리하고 응답을 보내지 않습니다.&#x20;
   *   이러한 상태 없는(stateless) 메시지 교환은 확장성 있는 메시징 시스템에서 효과적으로 사용됩니다. 즉, 메시지를 보낸 후 추가적인 처리나 응답을 기다리지 않고 다음 작업을 수행하는 방식입니다.\


       <figure><img src="../../.gitbook/assets/image (462).png" alt=""><figcaption></figcaption></figure>
2. **Request/reply Model:**
   * **요청(Request)**: 메시지를 발신하는 측이 메시지를 보내고, 응답을 기다립니다.
   * **응답(Reply)**: 메시지를 수신하는 측은 요청을 처리하고, 응답 메시지를 발신자에게 보냅니다.
   *   1:1 통신을 지원하며, 메시지의 안정성과 순서를 보장합니다. 요청과 응답이 짝지어져 있으므로, 특정 작업을 수행하고 그 결과를 돌려받아야 할 때 유용하게 사용됩니다

       <figure><img src="../../.gitbook/assets/image (463).png" alt=""><figcaption></figcaption></figure>

### **3-2. Publish-Subscribe (Pub/Sub) 모델**:

* 메시지를 발행하는 Publisher가 특정 주제(topic)에 메시지를 보냅니다.
* 해당 주제를 구독(subscribe)해놓은 모든 Subscriber가 메시지를 받습니다.
* Pub/Sub 모델은 1:N 통신을 지원하며, 메시지의 브로드캐스팅과 유연한 확장성을 제공합니다.

<figure><img src="../../.gitbook/assets/image (469).png" alt=""><figcaption></figcaption></figure>

#### 3-2-1.   Event Channel

객체 (Subscriber)와 이벤트 발생 객체 (Publisher) 사이에 위치하는 Event Channel이 있어 다음과 같이 동작합니다.

* Publisher는 Subscriber를 모른체로 이벤트 발생 시 Event Channel에게 메시지를 넘겨주고 (push),&#x20;
* 중간 컴포넌트는 이벤트들을 필터링해서 받아야 할 수신자들에게 보내줍니다.&#x20;
* &#x20;Subscriber는 Publisher에 대한 정보 없이 자신의 Interest에 맞는 메시지만을 전송 받는 것을 말합니다.&#x20;
* Pub/Sub 모델은 응답과 상관없이 중간 객체를 건너가기 때문에 비동기 방식으로 동작합니다
* Pub/Sub 모델은 대용량 데이터 처리 배치 작업, 채팅, 알림 등에 활용됩니다.

#### 3-2-1.  Pub/Sub 모델의 장점

* **비동기**: 동기식 요청-응답 방식이면, 끊임없이 메시지를 주고받는 채팅 시스템과 같은 상황에서 유연하게 대처할 수 없습니다.
* **Decoupling (결합도 감소)**: 어플리케이션과 분리되어 있기 때문에 코드 관리, 재사용성, 안정성이 높아집니다.
* **Scalable (확장성)**: 다수의 프로세스들이 큐에 메시지를 보낼 수 있습니다.

## 4. 비동기 메시징

비동기 메시징은 대규모 데이터 처리, 이벤트 기반 아키텍처, 이미지 프로세싱과 같이 무거운 작업을 요청하거나 이벤트 발생을 알리는 용도로 많이 사용됩니다

<figure><img src="../../.gitbook/assets/image (475).png" alt=""><figcaption><p>동기/비동기 </p></figcaption></figure>

<mark style="color:purple;">**= 비동기 메시징 장점 =**</mark>

* **비동기 (Asynchronous)**: 메시지를 큐에 넣기 때문에 후처리가 가능하여  요청과 결과가 동시에 발생하지 않으며, 여러 요청을 동시에 보낼 수 있습니다. 이는 응답을 기다리지 않고 다른 작업을 수행할 수 있어 자원을 효율적으로 사용할 수 있습니다
* **비동조 (Decoupling)**: 비동기 메시징은 애플리케이션과 분리 가능하여 시스템 간의 의존성을 낮추고 유연성을 높입니다.
* **탄력성 (Resilience)**: 일부가 실패해도 전체 시스템에 영향을 미치지 않으므로 메시지 큐를 통해 안정성을 보장할 수 있습니다.
* **과잉 (Redundancy)**: 실패할 경우 재실행이 가능하며, 메시지가 유실되지 않습니다.
* **보증 (Guarantees)**: 작업 완료를 확인할 수 있어메시지가 정확하게 전달되었는지 확인할 수 있습니다.
* **확장성 (Scalable)**: 다수의 프로세스가 큐에 메시지를 보낼 수 있어 시스템의 확장성을 높입니다.

## 5. 사용 애플리케이션

빅 테이터 및 실시간 처리에 있어 메시지 애프리케이션을 다음과 같이 다양하게 사용됩니다.

<figure><img src="../../.gitbook/assets/image (459).png" alt=""><figcaption></figcaption></figure>

* 빅 데이터 스트리밍 애플리케이션:  IOT 수집기, 로그 수집기
* 알림 서비스
* 뉴스피드 서비스
* 채팅 서비스
* 마이크로 서비스 간 통신
* 실시간 데이터 파이프라인: 스트리밍 데이터를 수집하고 저장하며, 데이터 파이프라인을 구동하는 애플리케이션에 읽기 서비스
* 데이터 스트리밍:  실시간 데이터 피드를 관리하고 데이터 지연 시간을 낮추며 원하는 곳으로 데이터를 전달하는 용도로 활용됩니다
* 백그라운드에서 실행되는 장기 프로세스 및 백그라운드 작업: 웹 서버에 어떤 요청을 받고 시간이 오래 걸리는 작업



